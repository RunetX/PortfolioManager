#Область ПрограммныйИнтерфейс

Функция ОписаниеРезультата() Экспорт

	Результат = Новый Структура;

	Результат.Вставить("ПроизошлаОшибка", Ложь);
	Результат.Вставить("ТекстОшибки", 	  "");
	Результат.Вставить("Данные");

	Возврат Результат;
	
КонецФункции

Функция ФиксированныеДанные(Данные) Экспорт

	Если ТипЗнч(Данные) = Тип("Массив") Тогда

		Массив = Новый Массив;
		
		Для Каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение));
			Иначе
				Массив.Добавить(Значение);
			КонецЕсли;
			
		КонецЦикла;

		Результат = Новый ФиксированныйМассив(Массив);
	  
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
		ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда

		Коллекция = Неопределено;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
	  		Коллекция = Новый Структура;
		Иначе
	  		Коллекция = Новый Соответствие;
		КонецЕсли;
		
	    Для каждого КлючИЗначение Из Данные Цикл

			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(КлючИЗначение.Ключ, ФиксированныеДанные(Значение));
			Иначе
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;

	    КонецЦикла;

		Если ТипЗнч(Данные) = Тип("Структура") Тогда
	    	Результат = Новый ФиксированнаяСтруктура(Коллекция);
	    Иначе
	      	Результат = Новый ФиксированноеСоответствие(Коллекция);
	    КонецЕсли;

	Иначе
		Результат = Данные;
	КонецЕсли;
  
  	Возврат Результат;

КонецФункции

Функция КлиентМосбиржи(Параметры = Неопределено) Экспорт
    Возврат Обработки.УА_КлиентМосбиржи.Создать().Инит(Параметры);
КонецФункции

// Оптимизирует портфель под целевые веса индекса
//
// Параметры:
//   Портфель - СправочникСсылка.УА_Портфели - ссылка на портфель для оптимизации
//   Индекс - СправочникСсылка.УА_Индексы - ссылка на целевой индекс
//   СуммаДляИнвестирования - Число - доступная сумма для инвестирования
//   СтратегияОперации - Строка - "ТолькоПокупка" или "ПокупкаПродажа"
//
// Возвращаемое значение:
//   Структура - результат оптимизации:
//     * ТаблицаОпераций - ТаблицаЗначений с рекомендованными операциями
//     * ИтоговаяОшибка - Число - итоговая ошибка отклонения от целевых весов
//     * ИспользованнаяСумма - Число - фактически использованная сумма
//     * ТекстОшибки - Строка - описание ошибки при возникновении
//     * ПроизошлаОшибка - Булево - признак ошибки
//
Функция ОптимизироватьПортфель(Портфель, Индекс, СуммаДляИнвестирования, СтратегияОперации = "ТолькоПокупка") Экспорт
   
   Результат = УА_ОбщегоНазначения.ОписаниеРезультата();
   Результат.Вставить("ТаблицаОпераций", Новый ТаблицаЗначений);
   Результат.Вставить("ИтоговаяОшибка", 0);
   Результат.Вставить("ИспользованнаяСумма", 0);
   
   // Проверка входных параметров
   Если НЕ ЗначениеЗаполнено(Портфель) Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Не указан портфель для оптимизации";
   	Возврат Результат;
   КонецЕсли;
   
   Если НЕ ЗначениеЗаполнено(Индекс) Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Не указан целевой индекс";
   	Возврат Результат;
   КонецЕсли;
   
   Если СуммаДляИнвестирования < 0 Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Сумма для инвестирования не может быть отрицательной";
   	Возврат Результат;
   КонецЕсли;
   
   // Инициализация таблицы операций
   ИнициализироватьТаблицуОпераций(Результат.ТаблицаОпераций);
   
   // Получение объединенных данных портфеля и индекса с ценами
   РезультатПолученияДанных = ПолучитьДанныеДляОптимизации(Портфель, Индекс);
   Если РезультатПолученияДанных.ПроизошлаОшибка Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = РезультатПолученияДанных.ТекстОшибки;
   	Возврат Результат;
   КонецЕсли;
   
   ДанныеДляОптимизации = РезультатПолученияДанных.Данные;
   
   // Расчет текущей стоимости портфеля
   ТекущаяСтоимостьПортфеля = РассчитатьТекущуюСтоимостьПортфеля(ДанныеДляОптимизации);
   
   // Целевая стоимость портфеля после инвестирования
   ЦелеваяСтоимостьПортфеля = ТекущаяСтоимостьПортфеля + СуммаДляИнвестирования;
   
   Если СтратегияОперации = "ТолькоПокупка" Тогда
   	ВыполнитьОптимизациюТолькоПокупка(ДанныеДляОптимизации, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат);
   Иначе
   	ВыполнитьОптимизациюПокупкаПродажа(ДанныеДляОптимизации, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат);
   КонецЕсли;
   
   Возврат Результат;
   
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьДанныеДляОптимизации(Портфель, Индекс)
   
   Результат = УА_ОбщегоНазначения.ОписаниеРезультата();
   
   Запрос = Новый Запрос;
   Запрос.УстановитьПараметр("Портфель", Портфель);
   Запрос.УстановитьПараметр("Индекс", Индекс);
   
   Запрос.Текст = "
   |ВЫБРАТЬ
   |	УА_ПортфелиСостав.Инструмент КАК Инструмент,
   |	УА_ПортфелиСостав.Количество КАК ТекущееКоличество
   |ПОМЕСТИТЬ врПортфель
   |ИЗ
   |	Справочник.УА_Портфели.Состав КАК УА_ПортфелиСостав
   |ГДЕ
   |	УА_ПортфелиСостав.Ссылка = &Портфель
   |;
   |
   |////////////////////////////////////////////////////////////////////////////////
   |ВЫБРАТЬ
   |	УА_ИндексыСостав.Инструмент КАК Инструмент,
   |	УА_ИндексыСостав.Вес КАК ЦелевойВес
   |ПОМЕСТИТЬ врИндекс
   |ИЗ
   |	Справочник.УА_Индексы.Состав КАК УА_ИндексыСостав
   |ГДЕ
   |	УА_ИндексыСостав.Ссылка = &Индекс
   |	И НЕ УА_ИндексыСостав.Инструмент.ПометкаУдаления
   |;
   |
   |////////////////////////////////////////////////////////////////////////////////
   |ВЫБРАТЬ
   |	ЕСТЬNULL(врИндекс.Инструмент, врПортфель.Инструмент) КАК Инструмент,
   |	ЕСТЬNULL(врПортфель.ТекущееКоличество, 0) КАК ТекущееКоличество,
   |	ЕСТЬNULL(врИндекс.ЦелевойВес, 0) КАК ЦелевойВес,
   |	ЕСТЬNULL(УА_ЦеныИнструментовСрезПоследних.Цена, 0) КАК ТекущаяЦена
   |ИЗ
   |	врИндекс КАК врИндекс
   |		ПОЛНОЕ СОЕДИНЕНИЕ врПортфель КАК врПортфель
   |		ПО врИндекс.Инструмент = врПортфель.Инструмент
   |		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УА_ЦеныИнструментов.СрезПоследних КАК УА_ЦеныИнструментовСрезПоследних
   |		ПО (ЕСТЬNULL(врИндекс.Инструмент, врПортфель.Инструмент) = УА_ЦеныИнструментовСрезПоследних.Инструмент)
   |ГДЕ
   |	НЕ ЕСТЬNULL(врИндекс.Инструмент.ПометкаУдаления, врПортфель.Инструмент.ПометкаУдаления)
   |	И ЕСТЬNULL(УА_ЦеныИнструментовСрезПоследних.Цена, 0) > 0";
   
   Попытка
   	ТаблицаДанных = Запрос.Выполнить().Выгрузить();
   	
   	Если ТаблицаДанных.Количество() = 0 Тогда
   		Результат.ПроизошлаОшибка = Истина;
   		Результат.ТекстОшибки = "Нет данных для оптимизации. Проверьте состав портфеля, индекса и наличие цен";
   		Возврат Результат;
   	КонецЕсли;
   	
   	// Проверим, что есть цены для всех инструментов
   	КоличествоБезЦен = 0;
   	Для Каждого СтрокаДанных Из ТаблицаДанных Цикл
   		Если СтрокаДанных.ТекущаяЦена = 0 Тогда
   			КоличествоБезЦен = КоличествоБезЦен + 1;
   		КонецЕсли;
   	КонецЦикла;
   	
   	Если КоличествоБезЦен > 0 Тогда
   		ТекстПредупреждения = СтрШаблон("Для %1 инструментов отсутствуют актуальные цены. Рекомендуется обновить цены перед оптимизацией", КоличествоБезЦен);
   		Сообщить(ТекстПредупреждения);
   	КонецЕсли;
   	
   	Результат.Данные = ТаблицаДанных;
   	
   Исключение
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Ошибка при получении данных для оптимизации: " + ОписаниеОшибки();
   КонецПопытки;
   
   Возврат Результат;
   
КонецФункции

Процедура ИнициализироватьТаблицуОпераций(ТаблицаОпераций)
   
   ТаблицаОпераций.Колонки.Добавить("Инструмент", Новый ОписаниеТипов("СправочникСсылка.УА_БиржевыеИнструменты"));
   ТаблицаОпераций.Колонки.Добавить("ТипОперации", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(20)));
   ТаблицаОпераций.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
   ТаблицаОпераций.Колонки.Добавить("Цена", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 2)));
   ТаблицаОпераций.Колонки.Добавить("Сумма", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 2)));
   ТаблицаОпераций.Колонки.Добавить("ТекущийВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   ТаблицаОпераций.Колонки.Добавить("ЦелевойВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   ТаблицаОпераций.Колонки.Добавить("Отклонение", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   
КонецПроцедуры

Функция РассчитатьТекущуюСтоимостьПортфеля(ДанныеПортфеля)
   
   ТекущаяСтоимость = 0;
   
   Для Каждого СтрокаПортфеля Из ДанныеПортфеля Цикл
   	ТекущаяСтоимость = ТекущаяСтоимость + СтрокаПортфеля.ТекущееКоличество * СтрокаПортфеля.ТекущаяЦена;
   КонецЦикла;
   
   Возврат ТекущаяСтоимость;
   
КонецФункции

Процедура ВыполнитьОптимизациюТолькоПокупка(ДанныеПортфеля, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат)
	
	// Копируем данные для работы
	РабочаяТаблица = ДанныеПортфеля.Скопировать();
	РабочаяТаблица.Колонки.Добавить("НовоеКоличество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
	РабочаяТаблица.Колонки.Добавить("ТекущийВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
	РабочаяТаблица.Колонки.Добавить("Отклонение", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
	РабочаяТаблица.Колонки.Добавить("РазмерЛота", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
	РабочаяТаблица.Колонки.Добавить("СтоимостьЛота", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 2)));
	
	// Получаем размеры лотов одним запросом
	ЗаполнитьРазмерыЛотов(РабочаяТаблица);
	
	// Инициализируем новое количество текущим и рассчитываем стоимость лота
	Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
		СтрокаТаблицы.НовоеКоличество = СтрокаТаблицы.ТекущееКоличество;
		СтрокаТаблицы.СтоимостьЛота = СтрокаТаблицы.РазмерЛота * СтрокаТаблицы.ТекущаяЦена;
	КонецЦикла;
	
	ОставшаясяСумма = СуммаДляИнвестирования;
	
	// Жадный алгоритм: покупаем лоты активов с наибольшим недовесом
	Пока ОставшаясяСумма > 0 Цикл
		
		// Пересчитываем веса и отклонения
		ПересчитатьВесаИОтклонения(РабочаяТаблица, ЦелеваяСтоимостьПортфеля);
		
		// Находим актив с максимальным недовесом, который можем купить целым лотом
		МинОтклонение = 999999;
		ИндексМинОтклонения = -1;
		
		Для Индекс = 0 По РабочаяТаблица.Количество() - 1 Цикл
			СтрокаТаблицы = РабочаяТаблица[Индекс];
			
			// Ищем активы с недовесом, которые можем купить целым лотом
			Если СтрокаТаблицы.Отклонение < МинОтклонение 
				И СтрокаТаблицы.СтоимостьЛота <= ОставшаясяСумма 
				И СтрокаТаблицы.ЦелевойВес > 0 
				И СтрокаТаблицы.РазмерЛота > 0 Тогда
				
				МинОтклонение = СтрокаТаблицы.Отклонение;
				ИндексМинОтклонения = Индекс;
			КонецЕсли;
		КонецЦикла;
		
		// Если не нашли актив для покупки, выходим
		Если ИндексМинОтклонения = -1 Тогда
			Прервать;
		КонецЕсли;
		
		// Покупаем один лот актива
		СтрокаДляПокупки = РабочаяТаблица[ИндексМинОтклонения];
		СтрокаДляПокупки.НовоеКоличество = СтрокаДляПокупки.НовоеКоличество + СтрокаДляПокупки.РазмерЛота;
		ОставшаясяСумма = ОставшаясяСумма - СтрокаДляПокупки.СтоимостьЛота;
		
	КонецЦикла;
	
	// Формируем таблицу операций
	ЗаполнитьТаблицуОпераций(РабочаяТаблица, Результат.ТаблицаОпераций);
	
	// Рассчитываем итоговую ошибку и использованную сумму
	РассчитатьИтоговыеПоказатели(РабочаяТаблица, ЦелеваяСтоимостьПортфеля, СуммаДляИнвестирования - ОставшаясяСумма, Результат);
	
КонецПроцедуры

Процедура ВыполнитьОптимизациюПокупкаПродажа(ДанныеПортфеля, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат)
	
	// Копируем данные для работы
	РабочаяТаблица = ДанныеПортфеля.Скопировать();
	РабочаяТаблица.Колонки.Добавить("НовоеКоличество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
	РабочаяТаблица.Колонки.Добавить("ТекущийВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
	РабочаяТаблица.Колонки.Добавить("Отклонение", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
	РабочаяТаблица.Колонки.Добавить("РазмерЛота", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
	РабочаяТаблица.Колонки.Добавить("СтоимостьЛота", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 2)));
	
	// Получаем размеры лотов одним запросом
	ЗаполнитьРазмерыЛотов(РабочаяТаблица);
	
	// Инициализируем данные и рассчитываем стоимость лота
	Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
		СтрокаТаблицы.НовоеКоличество = СтрокаТаблицы.ТекущееКоличество;
		СтрокаТаблицы.СтоимостьЛота = СтрокаТаблицы.РазмерЛота * СтрокаТаблицы.ТекущаяЦена;
	КонецЦикла;
	
	// Рассчитываем целевые количества для каждого актива с учетом лотности
	Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
		ЦелеваяСтоимостьАктива = ЦелеваяСтоимостьПортфеля * СтрокаТаблицы.ЦелевойВес / 100;
		
		Если СтрокаТаблицы.РазмерЛота > 0 И СтрокаТаблицы.ТекущаяЦена > 0 Тогда
			// Рассчитываем количество лотов
			ЦелевоеКоличествоЛотов = Окр(ЦелеваяСтоимостьАктива / СтрокаТаблицы.СтоимостьЛота, 0);
			СтрокаТаблицы.НовоеКоличество = Макс(0, ЦелевоеКоличествоЛотов * СтрокаТаблицы.РазмерЛота);
		Иначе
			СтрокаТаблицы.НовоеКоличество = 0;
		КонецЕсли;
	КонецЦикла;
	
	// Корректируем количества с учетом доступной суммы и лотности
	КорректироватьКоличестваПоСуммеСЛотами(РабочаяТаблица, СуммаДляИнвестирования);
	
	// Формируем таблицу операций
	ЗаполнитьТаблицуОпераций(РабочаяТаблица, Результат.ТаблицаОпераций);
	
	// Рассчитываем итоговую ошибку и использованную сумму
	ИспользованнаяСумма = РассчитатьИспользованнуюСумму(РабочаяТаблица);
	РассчитатьИтоговыеПоказатели(РабочаяТаблица, ЦелеваяСтоимостьПортфеля, ИспользованнаяСумма, Результат);
	
КонецПроцедуры

// Заполняет размеры лотов одним запросом для всех инструментов
Процедура ЗаполнитьРазмерыЛотов(РабочаяТаблица)
	
	// Собираем список инструментов
	МассивИнструментов = Новый Массив;
	Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
		Если МассивИнструментов.Найти(СтрокаТаблицы.Инструмент) = Неопределено Тогда
			МассивИнструментов.Добавить(СтрокаТаблицы.Инструмент);
		КонецЕсли;
	КонецЦикла;
	
	// Получаем размеры лотов одним запросом
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("МассивИнструментов", МассивИнструментов);
	Запрос.Текст = "ВЫБРАТЬ
	|	УА_ЦеныИнструментовСрезПоследних.Инструмент КАК Инструмент,
	|	ЕСТЬNULL(УА_ЦеныИнструментовСрезПоследних.Лот, 1) КАК Лот
	|ИЗ
	|	РегистрСведений.УА_ЦеныИнструментов.СрезПоследних КАК УА_ЦеныИнструментовСрезПоследних
	|ГДЕ
	|	УА_ЦеныИнструментовСрезПоследних.Инструмент В(&МассивИнструментов)";
	
	ТаблицаЛотов = Запрос.Выполнить().Выгрузить();
	
	// Создаем соответствие для быстрого поиска
	СоответствиеЛотов = Новый Соответствие;
	Для Каждого СтрокаЛота Из ТаблицаЛотов Цикл
		СоответствиеЛотов.Вставить(СтрокаЛота.Инструмент, Макс(1, СтрокаЛота.Лот));
	КонецЦикла;
	
	// Заполняем размеры лотов в рабочей таблице
	Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
		РазмерЛота = СоответствиеЛотов.Получить(СтрокаТаблицы.Инструмент);
		СтрокаТаблицы.РазмерЛота = ?(РазмерЛота = Неопределено, 1, РазмерЛота);
	КонецЦикла;
	
КонецПроцедуры

// Корректирует количества с учетом лотности торгов
Процедура КорректироватьКоличестваПоСуммеСЛотами(РабочаяТаблица, СуммаДляИнвестирования)
	
	// Рассчитываем разность между необходимой и доступной суммой
	НеобходимаяСумма = 0;
	
	Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
		РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
		НеобходимаяСумма = НеобходимаяСумма + РазностьКоличества * СтрокаТаблицы.ТекущаяЦена;
	КонецЦикла;
	
	Дефицит = НеобходимаяСумма - СуммаДляИнвестирования;
	
	// Если есть дефицит, корректируем операции с учетом лотности
	Если Дефицит > 0 Тогда
		
		// Создаем список активов для корректировки
		СписокДляКорректировки = Новый ТаблицаЗначений;
		СписокДляКорректировки.Колонки.Добавить("Индекс");
		СписокДляКорректировки.Колонки.Добавить("Отклонение");
		СписокДляКорректировки.Колонки.Добавить("СтоимостьЛота");
		СписокДляКорректировки.Колонки.Добавить("РазмерЛота");
		СписокДляКорректировки.Колонки.Добавить("ТипОперации"); // "Покупка" или "Продажа"
		
		Для Индекс = 0 По РабочаяТаблица.Количество() - 1 Цикл
			СтрокаТаблицы = РабочаяТаблица[Индекс];
			РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
			
			Если РазностьКоличества <> 0 И СтрокаТаблицы.РазмерЛота > 0 Тогда
				НоваяСтрока = СписокДляКорректировки.Добавить();
				НоваяСтрока.Индекс = Индекс;
				НоваяСтрока.Отклонение = СтрокаТаблицы.ЦелевойВес - СтрокаТаблицы.ТекущийВес;
				НоваяСтрока.СтоимостьЛота = СтрокаТаблицы.СтоимостьЛота;
				НоваяСтрока.РазмерЛота = СтрокаТаблицы.РазмерЛота;
				НоваяСтрока.ТипОперации = ?(РазностьКоличества > 0, "Покупка", "Продажа");
			КонецЕсли;
		КонецЦикла;
		
		// Сортируем: сначала продажи переве́сов, потом покупки недове́сов
		СписокДляКорректировки.Сортировать("Отклонение Убыв");
		
		// Корректируем количества лотами для покрытия дефицита
		Для Каждого СтрокаСписка Из СписокДляКорректировки Цикл
			Если Дефицит <= 0 Тогда
				Прервать;
			КонецЕсли;
			
			СтрокаРабочей = РабочаяТаблица[СтрокаСписка.Индекс];
			РазностьКоличества = СтрокаРабочей.НовоеКоличество - СтрокаРабочей.ТекущееКоличество;
			
			Если СтрокаСписка.ТипОперации = "Покупка" И РазностьКоличества > 0 Тогда
				// Уменьшаем покупку на целые лоты
				ТекущееКоличествоЛотов = РазностьКоличества / СтрокаСписка.РазмерЛота;
				УменьшениеЛотов = Мин(ТекущееКоличествоЛотов, Цел(Дефицит / СтрокаСписка.СтоимостьЛота));
				
				Если УменьшениеЛотов > 0 Тогда
					СтрокаРабочей.НовоеКоличество = СтрокаРабочей.НовоеКоличество - УменьшениеЛотов * СтрокаСписка.РазмерЛота;
					Дефицит = Дефицит - УменьшениеЛотов * СтрокаСписка.СтоимостьЛота;
				КонецЕсли;
				
			ИначеЕсли СтрокаСписка.ТипОперации = "Продажа" И РазностьКоличества < 0 Тогда
				// Увеличиваем продажу на целые лоты
				ТекущееКоличествоЛотов = -РазностьКоличества / СтрокаСписка.РазмерЛота;
				УвеличениеЛотов = Мин(ТекущееКоличествоЛотов, Цел(Дефицит / СтрокаСписка.СтоимостьЛота));
				
				// Проверяем, что не продаем больше, чем имеем
				МаксимальноеКоличествоДляПродажи = СтрокаРабочей.ТекущееКоличество;
				МаксимальноеКоличествоЛотовДляПродажи = Цел(МаксимальноеКоличествоДляПродажи / СтрокаСписка.РазмерЛота);
				
				УвеличениеЛотов = Мин(УвеличениеЛотов, МаксимальноеКоличествоЛотовДляПродажи);
				
				Если УвеличениеЛотов > 0 Тогда
					СтрокаРабочей.НовоеКоличество = СтрокаРабочей.НовоеКоличество - УвеличениеЛотов * СтрокаСписка.РазмерЛота;
					Дефицит = Дефицит - УвеличениеЛотов * СтрокаСписка.СтоимостьЛота;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ПересчитатьВесаИОтклонения(РабочаяТаблица, ЦелеваяСтоимостьПортфеля)
   
   ТекущаяСтоимость = 0;
   
   // Рассчитываем текущую стоимость портфеля
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	ТекущаяСтоимость = ТекущаяСтоимость + СтрокаТаблицы.НовоеКоличество * СтрокаТаблицы.ТекущаяЦена;
   КонецЦикла;
   
   // Рассчитываем веса и отклонения
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	Если ТекущаяСтоимость > 0 Тогда
   		СтрокаТаблицы.ТекущийВес = (СтрокаТаблицы.НовоеКоличество * СтрокаТаблицы.ТекущаяЦена / ТекущаяСтоимость) * 100;
   	Иначе
   		СтрокаТаблицы.ТекущийВес = 0;
   	КонецЕсли;
   	СтрокаТаблицы.Отклонение = СтрокаТаблицы.ТекущийВес - СтрокаТаблицы.ЦелевойВес;
   КонецЦикла;
   
КонецПроцедуры

Процедура ЗаполнитьТаблицуОпераций(РабочаяТаблица, ТаблицаОпераций)
   
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
   	
   	Если РазностьКоличества <> 0 Тогда
   		НоваяОперация = ТаблицаОпераций.Добавить();
   		НоваяОперация.Инструмент = СтрокаТаблицы.Инструмент;
   		НоваяОперация.Цена = СтрокаТаблицы.ТекущаяЦена;
   		НоваяОперация.ЦелевойВес = СтрокаТаблицы.ЦелевойВес;
   		
   		Если РазностьКоличества > 0 Тогда
   			НоваяОперация.ТипОперации = "Покупка";
   			НоваяОперация.Количество = -РазностьКоличества;
   		Иначе
   			НоваяОперация.ТипОперации = "Продажа";
   			НоваяОперация.Количество = -РазностьКоличества;
   		КонецЕсли;
   		
   		НоваяОперация.Сумма = НоваяОперация.Количество * НоваяОперация.Цена;
   		
   		// Рассчитываем текущий вес после операции
   		НоваяОперация.ТекущийВес = СтрокаТаблицы.ТекущийВес;
   		НоваяОперация.Отклонение = НоваяОперация.ТекущийВес - НоваяОперация.ЦелевойВес;
   	КонецЕсли;
   КонецЦикла;
   
КонецПроцедуры

Функция РассчитатьИспользованнуюСумму(РабочаяТаблица)
   
   ИспользованнаяСумма = 0;
   
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
   	ИспользованнаяСумма = ИспользованнаяСумма + РазностьКоличества * СтрокаТаблицы.ТекущаяЦена;
   КонецЦикла;
   
   Возврат ИспользованнаяСумма;
   
КонецФункции

Процедура РассчитатьИтоговыеПоказатели(РабочаяТаблица, ЦелеваяСтоимостьПортфеля, ИспользованнаяСумма, Результат)
   
   // Пересчитываем веса после операций
   ПересчитатьВесаИОтклонения(РабочаяТаблица, ЦелеваяСтоимостьПортфеля);
   
   // Рассчитываем среднеквадратичную ошибку
   СуммаКвадратовОтклонений = 0;
   КоличествоАктивов = 0;
   
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	Если СтрокаТаблицы.ЦелевойВес > 0 Тогда
   		СуммаКвадратовОтклонений = СуммаКвадратовОтклонений + Pow(СтрокаТаблицы.Отклонение, 2);
   		КоличествоАктивов = КоличествоАктивов + 1;
   	КонецЕсли;
   КонецЦикла;
   
   Если КоличествоАктивов > 0 Тогда
   	Результат.ИтоговаяОшибка = Sqrt(СуммаКвадратовОтклонений / КоличествоАктивов);
   Иначе
   	Результат.ИтоговаяОшибка = 0;
   КонецЕсли;
   
   Результат.ИспользованнаяСумма = ИспользованнаяСумма;
   
КонецПроцедуры

#КонецОбласти