#Область ПрограммныйИнтерфейс

Функция ОписаниеРезультата() Экспорт

	Результат = Новый Структура;

	Результат.Вставить("ПроизошлаОшибка", Ложь);
	Результат.Вставить("ТекстОшибки", 	  "");
	Результат.Вставить("Данные");

	Возврат Результат;
	
КонецФункции

Функция ФиксированныеДанные(Данные) Экспорт

	Если ТипЗнч(Данные) = Тип("Массив") Тогда

		Массив = Новый Массив;
		
		Для Каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение));
			Иначе
				Массив.Добавить(Значение);
			КонецЕсли;
			
		КонецЦикла;

		Результат = Новый ФиксированныйМассив(Массив);
	  
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
		ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда

		Коллекция = Неопределено;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
	  		Коллекция = Новый Структура;
		Иначе
	  		Коллекция = Новый Соответствие;
		КонецЕсли;
		
	    Для каждого КлючИЗначение Из Данные Цикл

			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(КлючИЗначение.Ключ, ФиксированныеДанные(Значение));
			Иначе
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;

	    КонецЦикла;

		Если ТипЗнч(Данные) = Тип("Структура") Тогда
	    	Результат = Новый ФиксированнаяСтруктура(Коллекция);
	    Иначе
	      	Результат = Новый ФиксированноеСоответствие(Коллекция);
	    КонецЕсли;

	Иначе
		Результат = Данные;
	КонецЕсли;
  
  	Возврат Результат;

КонецФункции

Функция КлиентМосбиржи(Параметры = Неопределено) Экспорт
    Возврат Обработки.УА_КлиентМосбиржи.Создать().Инит(Параметры);
КонецФункции

// Оптимизирует портфель под целевые веса индекса
//
// Параметры:
//   Портфель - СправочникСсылка.УА_Портфели - ссылка на портфель для оптимизации
//   Индекс - СправочникСсылка.УА_Индексы - ссылка на целевой индекс
//   СуммаДляИнвестирования - Число - доступная сумма для инвестирования
//   СтратегияОперации - Строка - "ТолькоПокупка" или "ПокупкаПродажа"
//
// Возвращаемое значение:
//   Структура - результат оптимизации:
//     * ТаблицаОпераций - ТаблицаЗначений с рекомендованными операциями
//     * ИтоговаяОшибка - Число - итоговая ошибка отклонения от целевых весов
//     * ИспользованнаяСумма - Число - фактически использованная сумма
//     * ТекстОшибки - Строка - описание ошибки при возникновении
//     * ПроизошлаОшибка - Булево - признак ошибки
//
Функция ОптимизироватьПортфель(Портфель, Индекс, СуммаДляИнвестирования, СтратегияОперации = "ТолькоПокупка") Экспорт
   
   Результат = УА_ОбщегоНазначения.ОписаниеРезультата();
   Результат.Вставить("ТаблицаОпераций", Новый ТаблицаЗначений);
   Результат.Вставить("ИтоговаяОшибка", 0);
   Результат.Вставить("ИспользованнаяСумма", 0);
   
   // Проверка входных параметров
   Если НЕ ЗначениеЗаполнено(Портфель) Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Не указан портфель для оптимизации";
   	Возврат Результат;
   КонецЕсли;
   
   Если НЕ ЗначениеЗаполнено(Индекс) Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Не указан целевой индекс";
   	Возврат Результат;
   КонецЕсли;
   
   Если СуммаДляИнвестирования < 0 Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Сумма для инвестирования не может быть отрицательной";
   	Возврат Результат;
   КонецЕсли;
   
   // Инициализация таблицы операций
   ИнициализироватьТаблицуОпераций(Результат.ТаблицаОпераций);
   
   // Получение объединенных данных портфеля и индекса с ценами
   РезультатПолученияДанных = ПолучитьДанныеДляОптимизации(Портфель, Индекс);
   Если РезультатПолученияДанных.ПроизошлаОшибка Тогда
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = РезультатПолученияДанных.ТекстОшибки;
   	Возврат Результат;
   КонецЕсли;
   
   ДанныеДляОптимизации = РезультатПолученияДанных.Данные;
   
   // Расчет текущей стоимости портфеля
   ТекущаяСтоимостьПортфеля = РассчитатьТекущуюСтоимостьПортфеля(ДанныеДляОптимизации);
   
   // Целевая стоимость портфеля после инвестирования
   ЦелеваяСтоимостьПортфеля = ТекущаяСтоимостьПортфеля + СуммаДляИнвестирования;
   
   Если СтратегияОперации = "ТолькоПокупка" Тогда
   	ВыполнитьОптимизациюТолькоПокупка(ДанныеДляОптимизации, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат);
   Иначе
   	ВыполнитьОптимизациюПокупкаПродажа(ДанныеДляОптимизации, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат);
   КонецЕсли;
   
   Возврат Результат;
   
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьДанныеДляОптимизации(Портфель, Индекс)
   
   Результат = УА_ОбщегоНазначения.ОписаниеРезультата();
   
   Запрос = Новый Запрос;
   Запрос.УстановитьПараметр("Портфель", Портфель);
   Запрос.УстановитьПараметр("Индекс", Индекс);
   
   Запрос.Текст = "
   |ВЫБРАТЬ
   |	УА_ПортфелиСостав.Инструмент КАК Инструмент,
   |	УА_ПортфелиСостав.Количество КАК ТекущееКоличество
   |ПОМЕСТИТЬ врПортфель
   |ИЗ
   |	Справочник.УА_Портфели.Состав КАК УА_ПортфелиСостав
   |ГДЕ
   |	УА_ПортфелиСостав.Ссылка = &Портфель
   |;
   |
   |////////////////////////////////////////////////////////////////////////////////
   |ВЫБРАТЬ
   |	УА_ИндексыСостав.Инструмент КАК Инструмент,
   |	УА_ИндексыСостав.Вес КАК ЦелевойВес
   |ПОМЕСТИТЬ врИндекс
   |ИЗ
   |	Справочник.УА_Индексы.Состав КАК УА_ИндексыСостав
   |ГДЕ
   |	УА_ИндексыСостав.Ссылка = &Индекс
   |	И НЕ УА_ИндексыСостав.Инструмент.ПометкаУдаления
   |;
   |
   |////////////////////////////////////////////////////////////////////////////////
   |ВЫБРАТЬ
   |	ЕСТЬNULL(врИндекс.Инструмент, врПортфель.Инструмент) КАК Инструмент,
   |	ЕСТЬNULL(врПортфель.ТекущееКоличество, 0) КАК ТекущееКоличество,
   |	ЕСТЬNULL(врИндекс.ЦелевойВес, 0) КАК ЦелевойВес,
   |	ЕСТЬNULL(УА_ЦеныИнструментовСрезПоследних.Цена, 0) КАК ТекущаяЦена
   |ИЗ
   |	врИндекс КАК врИндекс
   |		ПОЛНОЕ СОЕДИНЕНИЕ врПортфель КАК врПортфель
   |		ПО врИндекс.Инструмент = врПортфель.Инструмент
   |		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УА_ЦеныИнструментов.СрезПоследних КАК УА_ЦеныИнструментовСрезПоследних
   |		ПО (ЕСТЬNULL(врИндекс.Инструмент, врПортфель.Инструмент) = УА_ЦеныИнструментовСрезПоследних.Инструмент)
   |ГДЕ
   |	НЕ ЕСТЬNULL(врИндекс.Инструмент.ПометкаУдаления, врПортфель.Инструмент.ПометкаУдаления)
   |	И ЕСТЬNULL(УА_ЦеныИнструментовСрезПоследних.Цена, 0) > 0";
   
   Попытка
   	ТаблицаДанных = Запрос.Выполнить().Выгрузить();
   	
   	Если ТаблицаДанных.Количество() = 0 Тогда
   		Результат.ПроизошлаОшибка = Истина;
   		Результат.ТекстОшибки = "Нет данных для оптимизации. Проверьте состав портфеля, индекса и наличие цен";
   		Возврат Результат;
   	КонецЕсли;
   	
   	// Проверим, что есть цены для всех инструментов
   	КоличествоБезЦен = 0;
   	Для Каждого СтрокаДанных Из ТаблицаДанных Цикл
   		Если СтрокаДанных.ТекущаяЦена = 0 Тогда
   			КоличествоБезЦен = КоличествоБезЦен + 1;
   		КонецЕсли;
   	КонецЦикла;
   	
   	Если КоличествоБезЦен > 0 Тогда
   		ТекстПредупреждения = СтрШаблон("Для %1 инструментов отсутствуют актуальные цены. Рекомендуется обновить цены перед оптимизацией", КоличествоБезЦен);
   		Сообщить(ТекстПредупреждения);
   	КонецЕсли;
   	
   	Результат.Данные = ТаблицаДанных;
   	
   Исключение
   	Результат.ПроизошлаОшибка = Истина;
   	Результат.ТекстОшибки = "Ошибка при получении данных для оптимизации: " + ОписаниеОшибки();
   КонецПопытки;
   
   Возврат Результат;
   
КонецФункции

Процедура ИнициализироватьТаблицуОпераций(ТаблицаОпераций)
   
   ТаблицаОпераций.Колонки.Добавить("Инструмент", Новый ОписаниеТипов("СправочникСсылка.УА_БиржевыеИнструменты"));
   ТаблицаОпераций.Колонки.Добавить("ТипОперации", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(20)));
   ТаблицаОпераций.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
   ТаблицаОпераций.Колонки.Добавить("Цена", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 2)));
   ТаблицаОпераций.Колонки.Добавить("Сумма", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 2)));
   ТаблицаОпераций.Колонки.Добавить("ТекущийВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   ТаблицаОпераций.Колонки.Добавить("ЦелевойВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   ТаблицаОпераций.Колонки.Добавить("Отклонение", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   
КонецПроцедуры

Функция РассчитатьТекущуюСтоимостьПортфеля(ДанныеПортфеля)
   
   ТекущаяСтоимость = 0;
   
   Для Каждого СтрокаПортфеля Из ДанныеПортфеля Цикл
   	ТекущаяСтоимость = ТекущаяСтоимость + СтрокаПортфеля.ТекущееКоличество * СтрокаПортфеля.ТекущаяЦена;
   КонецЦикла;
   
   Возврат ТекущаяСтоимость;
   
КонецФункции

Процедура ВыполнитьОптимизациюТолькоПокупка(ДанныеПортфеля, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат)
	
	// Копируем данные для работы
	РабочаяТаблица = ДанныеПортфеля.Скопировать();
	РабочаяТаблица.Колонки.Добавить("НовоеКоличество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
	РабочаяТаблица.Колонки.Добавить("ТекущийВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
	РабочаяТаблица.Колонки.Добавить("Отклонение", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
	
	// Инициализируем новое количество текущим
	Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
		СтрокаТаблицы.НовоеКоличество = СтрокаТаблицы.ТекущееКоличество;
	КонецЦикла;
	
	ОставшаясяСумма = СуммаДляИнвестирования;
	
	// Жадный алгоритм: покупаем активы с наибольшим недовесом
	Пока ОставшаясяСумма > 0 Цикл
		
		// Пересчитываем веса и отклонения
		ПересчитатьВесаИОтклонения(РабочаяТаблица, ЦелеваяСтоимостьПортфеля);
		
		// Находим актив с максимальным недовесом (самое отрицательное отклонение)
		МинОтклонение = 999999;  // Изменено: ищем минимальное отклонение
		ИндексМинОтклонения = -1;
		
		Для Индекс = 0 По РабочаяТаблица.Количество() - 1 Цикл
			СтрокаТаблицы = РабочаяТаблица[Индекс];
			// Ищем активы с недовесом (отрицательное отклонение), которые можем купить
			Если СтрокаТаблицы.Отклонение < МинОтклонение 
				И СтрокаТаблицы.ТекущаяЦена <= ОставшаясяСумма 
				И СтрокаТаблицы.ЦелевойВес > 0 Тогда  // Добавлена проверка на положительный целевой вес
				МинОтклонение = СтрокаТаблицы.Отклонение;
				ИндексМинОтклонения = Индекс;
			КонецЕсли;
		КонецЦикла;
		
		// Если не нашли актив для покупки, выходим
		Если ИндексМинОтклонения = -1 Тогда
			Прервать;
		КонецЕсли;
		
		// Покупаем одну единицу актива
		СтрокаДляПокупки = РабочаяТаблица[ИндексМинОтклонения];
		СтрокаДляПокупки.НовоеКоличество = СтрокаДляПокупки.НовоеКоличество + 1;
		ОставшаясяСумма = ОставшаясяСумма - СтрокаДляПокупки.ТекущаяЦена;
		
	КонецЦикла;
	
	// Формируем таблицу операций
	ЗаполнитьТаблицуОпераций(РабочаяТаблица, Результат.ТаблицаОпераций);
	
	// Рассчитываем итоговую ошибку и использованную сумму
	РассчитатьИтоговыеПоказатели(РабочаяТаблица, ЦелеваяСтоимостьПортфеля, СуммаДляИнвестирования - ОставшаясяСумма, Результат);
	
КонецПроцедуры

Процедура ВыполнитьОптимизациюПокупкаПродажа(ДанныеПортфеля, СуммаДляИнвестирования, ЦелеваяСтоимостьПортфеля, Результат)
   
   // Копируем данные для работы
   РабочаяТаблица = ДанныеПортфеля.Скопировать();
   РабочаяТаблица.Колонки.Добавить("НовоеКоличество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0)));
   РабочаяТаблица.Колонки.Добавить("ТекущийВес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   РабочаяТаблица.Колонки.Добавить("Отклонение", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 4)));
   
   // Инициализируем новое количество текущим
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	СтрокаТаблицы.НовоеКоличество = СтрокаТаблицы.ТекущееКоличество;
   КонецЦикла;
   
   // Рассчитываем целевые количества для каждого актива
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	Если СтрокаТаблицы.ЦелевойВес > 0 И СтрокаТаблицы.ТекущаяЦена > 0 Тогда
   		ЦелеваяСтоимостьАктива = ЦелеваяСтоимостьПортфеля * СтрокаТаблицы.ЦелевойВес / 100;
   		СтрокаТаблицы.НовоеКоличество = Макс(0, Окр(ЦелеваяСтоимостьАктива / СтрокаТаблицы.ТекущаяЦена, 0));
   	Иначе
   		// Если целевой вес 0, то продаем все
   		СтрокаТаблицы.НовоеКоличество = 0;
   	КонецЕсли;
   КонецЦикла;
   
   // Корректируем количества с учетом доступной суммы
   КорректироватьКоличестваПоСумме(РабочаяТаблица, СуммаДляИнвестирования);
   
   // Формируем таблицу операций
   ЗаполнитьТаблицуОпераций(РабочаяТаблица, Результат.ТаблицаОпераций);
   
   // Рассчитываем итоговую ошибку и использованную сумму
   ИспользованнаяСумма = РассчитатьИспользованнуюСумму(РабочаяТаблица);
   РассчитатьИтоговыеПоказатели(РабочаяТаблица, ЦелеваяСтоимостьПортфеля, ИспользованнаяСумма, Результат);
   
КонецПроцедуры

Процедура ПересчитатьВесаИОтклонения(РабочаяТаблица, ЦелеваяСтоимостьПортфеля)
   
   ТекущаяСтоимость = 0;
   
   // Рассчитываем текущую стоимость портфеля
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	ТекущаяСтоимость = ТекущаяСтоимость + СтрокаТаблицы.НовоеКоличество * СтрокаТаблицы.ТекущаяЦена;
   КонецЦикла;
   
   // Рассчитываем веса и отклонения
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	Если ТекущаяСтоимость > 0 Тогда
   		СтрокаТаблицы.ТекущийВес = (СтрокаТаблицы.НовоеКоличество * СтрокаТаблицы.ТекущаяЦена / ТекущаяСтоимость) * 100;
   	Иначе
   		СтрокаТаблицы.ТекущийВес = 0;
   	КонецЕсли;
   	СтрокаТаблицы.Отклонение = СтрокаТаблицы.ТекущийВес - СтрокаТаблицы.ЦелевойВес;
   КонецЦикла;
   
КонецПроцедуры

Процедура КорректироватьКоличестваПоСумме(РабочаяТаблица, СуммаДляИнвестирования)
   
   // Рассчитываем разность между необходимой и доступной суммой
   НеобходимаяСумма = 0;
   
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
   	НеобходимаяСумма = НеобходимаяСумма + РазностьКоличества * СтрокаТаблицы.ТекущаяЦена;
   КонецЦикла;
   
   Дефицит = НеобходимаяСумма - СуммаДляИнвестирования;
   
   // Если есть дефицит, уменьшаем покупки или увеличиваем продажи
   Если Дефицит > 0 Тогда
   	
   	// Создаем список активов для корректировки (сортируем по убыванию отклонения)
   	СписокДляКорректировки = Новый ТаблицаЗначений;
   	СписокДляКорректировки.Колонки.Добавить("Индекс");
   	СписокДляКорректировки.Колонки.Добавить("Отклонение");
   	СписокДляКорректировки.Колонки.Добавить("Цена");
   	СписокДляКорректировки.Колонки.Добавить("РазностьКоличества");
   	
   	Для Индекс = 0 По РабочаяТаблица.Количество() - 1 Цикл
   		СтрокаТаблицы = РабочаяТаблица[Индекс];
   		РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
   		
   		Если РазностьКоличества <> 0 Тогда
   			НоваяСтрока = СписокДляКорректировки.Добавить();
   			НоваяСтрока.Индекс = Индекс;
   			НоваяСтрока.Отклонение = СтрокаТаблицы.ЦелевойВес - СтрокаТаблицы.ТекущийВес;
   			НоваяСтрока.Цена = СтрокаТаблицы.ТекущаяЦена;
   			НоваяСтрока.РазностьКоличества = РазностьКоличества;
   		КонецЕсли;
   	КонецЦикла;
   	
   	СписокДляКорректировки.Сортировать("Отклонение Убыв");
   	
   	// Корректируем количества для покрытия дефицита
   	Для Каждого СтрокаСписка Из СписокДляКорректировки Цикл
   		Если Дефицит <= 0 Тогда
   			Прервать;
   		КонецЕсли;
   		
   		СтрокаРабочей = РабочаяТаблица[СтрокаСписка.Индекс];
   		РазностьКоличества = СтрокаСписка.РазностьКоличества;
   		
   		Если РазностьКоличества > 0 Тогда
   			// Уменьшаем покупку
   			УменьшениеНа = Мин(РазностьКоличества, Цел(Дефицит / СтрокаСписка.Цена));
   			СтрокаРабочей.НовоеКоличество = СтрокаРабочей.НовоеКоличество - УменьшениеНа;
   			Дефицит = Дефицит - УменьшениеНа * СтрокаСписка.Цена;
   		ИначеЕсли РазностьКоличества < 0 Тогда
   			// Увеличиваем продажу (но не больше имеющегося количества)
   			МаксВозможнаяПродажа = СтрокаРабочей.ТекущееКоличество;
   			УвеличениеНа = Мин(Мин(-РазностьКоличества, МаксВозможнаяПродажа), Цел(Дефицит / СтрокаСписка.Цена));
   			СтрокаРабочей.НовоеКоличество = СтрокаРабочей.НовоеКоличество - УвеличениеНа;
   			Дефицит = Дефицит - УвеличениеНа * СтрокаСписка.Цена;
   		КонецЕсли;
   	КонецЦикла;
   	
   КонецЕсли;
   
КонецПроцедуры

Процедура ЗаполнитьТаблицуОпераций(РабочаяТаблица, ТаблицаОпераций)
   
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
   	
   	Если РазностьКоличества <> 0 Тогда
   		НоваяОперация = ТаблицаОпераций.Добавить();
   		НоваяОперация.Инструмент = СтрокаТаблицы.Инструмент;
   		НоваяОперация.Цена = СтрокаТаблицы.ТекущаяЦена;
   		НоваяОперация.ЦелевойВес = СтрокаТаблицы.ЦелевойВес;
   		
   		Если РазностьКоличества > 0 Тогда
   			НоваяОперация.ТипОперации = "Покупка";
   			НоваяОперация.Количество = -РазностьКоличества;
   		Иначе
   			НоваяОперация.ТипОперации = "Продажа";
   			НоваяОперация.Количество = -РазностьКоличества;
   		КонецЕсли;
   		
   		НоваяОперация.Сумма = НоваяОперация.Количество * НоваяОперация.Цена;
   		
   		// Рассчитываем текущий вес после операции
   		НоваяОперация.ТекущийВес = СтрокаТаблицы.ТекущийВес;
   		НоваяОперация.Отклонение = НоваяОперация.ТекущийВес - НоваяОперация.ЦелевойВес;
   	КонецЕсли;
   КонецЦикла;
   
КонецПроцедуры

Функция РассчитатьИспользованнуюСумму(РабочаяТаблица)
   
   ИспользованнаяСумма = 0;
   
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	РазностьКоличества = СтрокаТаблицы.НовоеКоличество - СтрокаТаблицы.ТекущееКоличество;
   	ИспользованнаяСумма = ИспользованнаяСумма + РазностьКоличества * СтрокаТаблицы.ТекущаяЦена;
   КонецЦикла;
   
   Возврат ИспользованнаяСумма;
   
КонецФункции

Процедура РассчитатьИтоговыеПоказатели(РабочаяТаблица, ЦелеваяСтоимостьПортфеля, ИспользованнаяСумма, Результат)
   
   // Пересчитываем веса после операций
   ПересчитатьВесаИОтклонения(РабочаяТаблица, ЦелеваяСтоимостьПортфеля);
   
   // Рассчитываем среднеквадратичную ошибку
   СуммаКвадратовОтклонений = 0;
   КоличествоАктивов = 0;
   
   Для Каждого СтрокаТаблицы Из РабочаяТаблица Цикл
   	Если СтрокаТаблицы.ЦелевойВес > 0 Тогда
   		СуммаКвадратовОтклонений = СуммаКвадратовОтклонений + Pow(СтрокаТаблицы.Отклонение, 2);
   		КоличествоАктивов = КоличествоАктивов + 1;
   	КонецЕсли;
   КонецЦикла;
   
   Если КоличествоАктивов > 0 Тогда
   	Результат.ИтоговаяОшибка = Sqrt(СуммаКвадратовОтклонений / КоличествоАктивов);
   Иначе
   	Результат.ИтоговаяОшибка = 0;
   КонецЕсли;
   
   Результат.ИспользованнаяСумма = ИспользованнаяСумма;
   
КонецПроцедуры

#КонецОбласти